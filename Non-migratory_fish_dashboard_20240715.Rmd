---
title: "ORC fish dashboard"
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "reproducible.co.nz", href: "https://reproducible.co.nz", align: right }
    orientation: rows
    vertical_layout: fill
    theme: spacelab
    source_code: embed 
---
<style>

body {
  padding-top: 70px;
}


.navbar-brand {
font-family: "Candara";
  font-weight: bold;
  font-size: 24px;
}


</style>


```{r}
library(sf)
library(tidyverse)
library(lubridate)
library(leaflet)
library(shiny)
library(shinyWidgets)
library(flexdashboard)
library(plotly)
library(viridis)
library(DT)
library(readxl)
library(factoextra)
library(leaflet.extras)
library(geojsonsf)
library(jsonify)
library(stringr)
library(janitor)
library(lwgeom) # for st_split
library(tidygraph)
library(sfnetworks)
library(igraph)
library(scales)
library(ggspatial)
```


```{r}
# read spatial data

# regional boundaries
boundaries <- st_read("Regional boundaries\\regional-council-2022-generalised.shp", quiet = TRUE) %>%
  st_transform(2193)

# otago boundaries
otago <- boundaries %>% filter(boundaries$REGC2022_1 == "Otago Region") %>%
  st_transform(2193)

# catchments
catchments <- st_read("ORC_Catchments\\ORC_Catchments.shp", quiet = TRUE) 

# reads in REC files (gbd format)
rec <- st_read("C:\\Users\\Nathan\\Downloads\\REC2_geodata_version_5\\nzRec2_v5.gdb", quiet = TRUE)%>%
  st_transform(2193)

# reads in non-migratory data
non.mig <-  st_read(
  "Your Non-Migratory Freshwater Fish Distribution/Non_migratory_Freshwater_Fish_Distribution.shp",
  quiet = TRUE
) %>%
  st_transform(2193)

```



Sampling
=====================================

Column {.sidebar data-width=350}
-------------------------------------

**Upload species locations**

```{r}
# Upload

fileInput("file1", "Choose CSV File",
                    multiple = FALSE)


my.fish <- eventReactive(input$file1,{
  
  req(input$file1)
  
  fish <- read.csv(input$file1$datapath) %>%
    st_as_sf(coords = c("Long", "Lat"),
               crs = 4326) %>% 
    st_transform(crs = 2193)
  
  fish$ref <- 1:nrow(fish)
  
  fish
  


})
```

<br/>

**Choose catchment(s)**

Please narrow your search to only the catchments required (this minimises unnecessary computation).

```{r}

renderUI({  
selectInput("my.catchments", label = "Catchments", 
    choices = sort(unique(catchments.filtered()$Catchment)),
    multiple = TRUE
)
})
  
```

<br/>

**Choose Start-Finish)**

Click on the map to drop pins. If a popup appears click again to override.

```{r}
renderPrint({
  
  lat <- round(input$map_click$lat, 2) 
  long <- if(input$map_click$lng > 180){
    input$map_click$lng * -1
    } else{
      input$map_click$lng
    }
  long <- round(input$map_click$lng, 2) 
  
  start <- c(long, lat)
  start
  
  
  textInput("start", label = "Click to start", value = start )
  
  rv$markers
   
})
```


```{r}
rv <- reactiveValues(markers = data.frame())
```

<br/>

```{r}
renderUI({
  
  selectInput("start", label = "Start", 
    choices = sort(unique(my.fish()$ref)),
    selected = character(0)
  )
  
})

renderUI({
  
  selectInput("end", label = "End", 
    choices = sort(unique(my.fish()$ref)),
    selected = character(0)
  )

  
})

```

<br/>


```{r}
# Create a button for the user to submit the input
actionButton("submit", "Confirm start & end points")

my.start.end <- eventReactive(input$submit,{
  
  my.start.end <- my.fish() %>% filter(ref %in% c(input$start, input$end))
  my.start.end
  
})
```


<br/>
<br/>
```{r}
# inclusion of non-mig data
radioButtons(
  "fishdata",
  label = HTML("<b>Include non-migratory fish data</b>"),
  choices = c("No", "Yes"),
  selected = "Yes"
)
```

<br/>

```{r}
renderUI({
  conditionalPanel(
    condition = "input.fishdata == 'Yes'",
    
   selectInput("species.sel", 
               label = HTML("<b>Comparison species</b>"),
               choices = sort(unique(non.mig$Species)),
               selected = "Galaxias depressiceps")
  )
})
```

<br/>

```{r}

renderUI({
  
 my.dates <- ymd(my.fish()$Collection.date)
  
 dateRangeInput('dateRange',
      label = HTML("<b>Date range of collection dates </b>"),
      start = min(my.dates), end = max(my.dates)
    )
  
})
```






```{r}
non.mig.known <- reactive({
  non.mig.known <- non.mig %>% filter(Species == input$species.sel)
  
  non.mig.known
  
})
```


```{r}
# filter non-migratory data
my.species <- "Galaxias depressiceps"
known <- non.mig %>% filter(Species == my.species)
```

```{r}
# buffer in meters
my.buffer <- 20
known.buffered <- st_buffer(known, my.buffer )%>%
  st_transform(2193)
```

```{r}
# compile max reasonable extent
box.known <-  
  st_as_sfc(st_bbox(known)) %>% 
  st_as_sf() %>%
  st_buffer(10000)

box.my <- reactive({
  
  st_as_sfc(st_bbox(my.fish())) %>% 
  st_as_sf() %>% 
  st_buffer(10000)
  
}) 
  

# join and find extent for cropping

rec.species <- reactive({
  
  combined <- rbind(box.known, box.my())
  combined <- st_as_sfc(st_bbox(combined)) %>% 
  st_as_sf()  
  
  rec.species <- st_crop(rec, combined) 
  rec.species
  
})




```


```{r}
# otago catchments

catchments.filtered  <- reactive({
  
  catchments$show <- 
  ifelse(lengths(st_intersects(catchments, known.buffered)) > 0 |
                   lengths(st_intersects(catchments, my.fish())) >0,
                           "yes",
                           "no")

catchments.filtered <- catchments %>% filter(show == "yes")
catchments.filtered 

})



```

```{r}
# reduce 
masked.rec.species <- reactive({
  
  st_intersection(rec.species(), final.catchments())
  
})
```



Column
-------------------------------------


```{r}


output$map  <- renderLeaflet({
 
  leaflet(options = leafletOptions(worldCopyJump = TRUE)) %>%
        setView(lng = 169,
          lat = -45.9,
          zoom = 8) %>%
    # add base maps
    addProviderTiles("Esri.WorldImagery",
                     # give the layer a name
                     group = "World")%>%
    addPolygons(
      data = catchments.filtered() %>% st_transform(crs = 4326),
      fillOpacity = 0.05,
      color = "red",
      weight = 3,
     popup = paste(catchments.filtered()$Catchment)
    ) %>%
    addPolylines(
      data = masked.rec.species() %>% st_transform(crs = 4326),
      fillOpacity = 0.001,
      color = "lightblue",
      weight = 3
    ) %>%
    addMeasure(
      position = "bottomleft",
      primaryLengthUnit = "kilometers",
      primaryAreaUnit = "ha",
      activeColor = "lightyellow",
      completedColor = "orange"
    ) %>%
      addPolylines(data = non.mig.known() %>% st_transform(crs = 4326), 
               color = "yellow", 
               weight = 2)%>%
        addCircleMarkers(data = my.fish() %>%
                 st_transform(crs = 4326),
               popup = paste(my.fish()$ref), 
               fillOpacity = 1,
               color ="white",
               radius = 4)

  
})

icon.star <- makeAwesomeIcon(icon = 'star', markerColor = 'purple', library='ion')

  observeEvent(input$map_click, {
    
    rv$markers <- rbind(rv$markers, data.frame(long = input$map_click$lng, lat = input$map_click$lat)
    )
    
       # If there are more than 2 markers, remove the oldest one
    if (nrow(rv$markers) > 2) {
      rv$markers <- rv$markers[-1,]
    }
    
    leafletProxy('map')%>%
      clearMarkers() %>%
    addCircleMarkers(data = my.fish() %>%
                 st_transform(crs = 4326),
               popup = paste(my.fish()$ref), 
               fillOpacity = 1,
               color ="white",
               radius = 4)%>%
      addAwesomeMarkers(lng = rv$markers$long, lat = rv$markers$lat, icon = icon.star)
  })
    
leafletOutput('map', height =900)

```



Selection with barriers
=====================================


Column {.sidebar data-width=350}
-------------------------------------

The fish barriers in the river catchment will appear to your right.


```{r}
# filter by my catchments

final.catchments <- reactive({
  
  final.catchments <- catchments.filtered() %>% 
    filter(Catchment %in% input$my.catchments)
  final.catchments 
  
  
})

```


Column
-------------------------------------

```{r}


barriers <- reactive({
  barriers <- read.csv("Fish barriers/FishPassageSearchResults.csv")
  
  barriers <- barriers %>%
    st_as_sf(coords = c("longitude", "latitude"),
             crs = 4326)
  
  barriers <- barriers %>%
    select(
      structure.type_structure.type,
      risk.to.fish.passage_risk.to.fish.passage,
      asset.id.number_asset.id.number,
      asset.owner_asset.owner,
      stream_name,
      priority
    )
  
  colnames(barriers) <- c(
    "structure",
    "risk to passage",
    "asset id",
    "owner",
    "stream name",
    "priority",
    "geometry"
  )
  
  
  barriers <- st_intersection(barriers %>% 
                                st_transform(crs = 4326),
                              final.catchments() %>% 
                                st_transform(crs = 4326)) 
    
  
  barriers
  
})
```


```{r}

output$my.selection <- renderLeaflet({
  
  col.structure <- colorFactor(palette = c("red", "green", "blue", 
                                         "skyblue", "white", "yellow",
                                         "grey", "pink", "orange",
                                         "purple", "chartreuse"),
            levels = unique(barriers()$structure))
  
leaflet(options = leafletOptions(worldCopyJump = TRUE)) %>%
  
  # add base maps
  addProviderTiles("Esri.WorldImagery",
                   # give the layer a name
                   group = "World") %>%
  addMarkers(data = my.start.end() %>% 
               st_transform(crs = 4326)) %>%
  addPolygons(data = final.catchments() %>% 
                st_transform(crs = 4326),
              fillOpacity = 0.001,
              color = "red",
              weight = 3) %>%
    addPolylines(data = masked.rec.species() %>% 
                   st_transform(crs = 4326),
              fillOpacity = 0.001,
              color = "white",
              weight = 3)%>%
    addCircleMarkers(
    data = barriers(),
    color = ~ col.structure(structure),
    fillOpacity = 1,
    radius = 4,
    popup = paste(
      "Structure: ",
      barriers()$structure,
      "<br>",
      "Passage risk:",
      barriers()$`risk to passage`,
      "<br>",
      "Assest id:",
      barriers()$`asset id`,
      "<br>",
      "Owner:",
      barriers()$`owner`,
      "<br>",
      "Stream name:",
      barriers()$`stream name`,
      "<br>",
      "Priority:",
      barriers()$`priority`
    )
  ) %>%
  addLegend(
    data = barriers() ,
    position = "bottomright",
    pal = col.structure ,
    values = barriers()$structure,
    title = "Barrier type",
    na.label = ""
  ) %>%
  addMeasure(
    position = "bottomleft",
    primaryLengthUnit = "kilometers",
    primaryAreaUnit = "ha",
    activeColor = "lightyellow",
    completedColor = "orange"
  )
  
})

leafletOutput('my.selection', height = 900)
```



```{r}
########## Network analysis
# Step 1: make edges
edges <- reactive ({
  masked.rec.species() %>%
    mutate(edgeID = c(1:n()))
  
})


# Step 2: make nodes from edges
nodes <- reactive ({
  edges() %>%
    st_coordinates() %>%
    as_tibble() %>%
    rename(edgeID = L1) %>%
    group_by(edgeID) %>%
    slice(c(1, n())) %>%
    ungroup() %>%
    mutate(start_end = rep(c('start', 'end'), times = n() / 2))
  
})

# Step 3: Give each node a unique index

# make moniker
nodes.index  <- reactive ({
  nodes.index  <- nodes()
  
  nodes.index$xy <-  paste(nodes.index$X, nodes.index$Y)
  nodes.index$xy <-
    factor(nodes.index$xy, levels = unique(nodes.index$xy))
  nodes.index$nodeID <- as.numeric(nodes.index$xy)
  nodes.index$xy <- NULL
  
  nodes.index
  
})

# Step 4: Combine the node indices with the edges

edges2 <- reactive({
  source_nodes <- nodes.index() %>%
    filter(start_end == 'start') %>%
    pull(nodeID)
  
  target_nodes <- nodes.index() %>%
    filter(start_end == 'end') %>%
    pull(nodeID)
  
  edges2 <-  edges() %>%
    mutate(from = source_nodes, to = target_nodes)
  
  edges2
  
})


# Step 5: Remove duplicate nodes
nodes2 <- reactive({
  nodes2 <- nodes.index() %>%
    distinct(nodeID, .keep_all = TRUE) %>%
    select(-c(edgeID, start_end)) %>%
    st_as_sf(coords = c('X', 'Y')) %>%
    st_set_crs(st_crs(edges2()))
  
  nodes2
  
})

# make tibble graph



# Step 6: Convert to tbl_graph
graph <-  reactive({
  # note that nodes and edges now refer to the tbl_graph variables
  # not reactive object
  my.graph <- tbl_graph(nodes = nodes2(),
                        edges = as_tibble(edges2()),
                        directed = FALSE) %>%
    activate(edges) %>%
    mutate(length = st_length(st_geometry(edges2())))
  
  my.graph
  
})


# Step 7: Get all nodes in the network

all_nodes <- reactive({
  all.nodes <- tbl_graph(nodes = nodes2(),
                         edges = as_tibble(edges2()),
                         directed = FALSE) %>%
    activate(edges) %>%
    mutate(length = st_length(st_geometry(edges2()))) %>%
    activate(nodes) %>%
    as_tibble() %>%
    st_as_sf()
  
  
  all.nodes
  
})


# Step 8: Get coordinates of all nodes in the network

all_coords <- reactive({
  all_nodes() %>%
    st_coordinates()
  
})

```


```{r}
# find nearest point on line point will be nearest edge(need to snap to line)
origin.points <- reactive({
  
  feature_o <- edges2()[st_nearest_feature(my.start.end()[1,], edges2()),]
  
  # sample feature every 10 m
  ten.m.lengths <-round(as.numeric(st_length(feature_o))/ 10  , 0)
  
  origin.points <- st_sample(feature_o,
                             size = ten.m.lengths, type = "regular") %>%
    st_as_sf() %>%
    st_cast("POINT")
  
  # nearest point spatial feature
  nearest_to_origin <- st_nearest_feature(my.start.end()[1,], origin.points)
  
  # nearest edge on network
  no <- origin.points[nearest_to_origin,]
  
  no
  
})

destination.points <- reactive({
  
  feature_d <- edges2()[st_nearest_feature(my.start.end()[2,], edges2()),]
  
  # sample feature every 10 m
  ten.m.lengths <-round(as.numeric(st_length(feature_d))/ 10  , 0)
  
  destination.points <- st_sample(feature_d,
                             size = ten.m.lengths, type = "regular") %>%
    st_as_sf() %>%
    st_cast("POINT")
  
    # nearest point spatial feature
  nearest_to_des <- st_nearest_feature(my.start.end()[2,], destination.points)
  
  # nearest edge on network
  nd <- destination.points[nearest_to_des,]
  
  nd
  
  
  
  
})

```


Barriers within buffer
=====================================


Column {.sidebar data-width=350}
-------------------------------------

Note: the REC river system is rather coarse and will often be misaligned with the actual river pass. Consequently, fish passage barriers should be buffered to allow inclusion

<br/>

```{r}
sliderInput("my.buffer", "Select buffer (m)",
             min = 0, max = 100, value = 50, ticks = 10)
```




Column 
-------------------------------------

```{r}


output$my.buffer  <- renderLeaflet({
 
  buffered <- st_transform(middle(), crs = 2193)
  buffered <- st_buffer(buffered, input$my.buffer) %>%
    st_transform(crs = 4326)
  
  barrier.buff <- st_intersection(barriers() %>%
                                    st_transform(crs = 4326),
                                  buffered)
  
  col.structure <- colorFactor(palette = c("red", "green", "blue", 
                                         "skyblue", "white", "yellow",
                                         "grey", "pink", "orange",
                                         "purple", "chartreuse"),
            levels = unique(barriers()$structure))
  
  
  
  
  leaflet(options = leafletOptions(worldCopyJump = TRUE)) %>%
    
    # add base maps
    addProviderTiles("Esri.WorldImagery",
                     # give the layer a name
                     group = "World") %>%
    # set zoom and position
    addMarkers(data = my.start.end() %>%
                 st_transform(crs = 4326)) %>%
    addPolylines(
      data = middle() %>%
        st_transform(crs = 4326),
      fillOpacity = 0.001,
      color = "yellow",
      weight = 3
    ) %>%
    addPolylines(
      data = buffered %>%
        st_transform(crs = 4326),
      fillOpacity = 0.001,
      color = "red",
      weight = 3
    ) %>%
    addCircleMarkers(
      data = barrier.buff ,
      color = ~ col.structure(structure),
      fillOpacity = 1,
      radius = 4,
      popup = paste(
        "Structure: ",
        barrier.buff$structure,
        "<br>",
        "Passage risk:",
        barrier.buff$`risk to passage`,
        "<br>",
        "Assest id:",
        barrier.buff$`asset id`,
        "<br>",
        "Owner:",
        barrier.buff$`owner`,
        "<br>",
        "Stream name:",
        barrier.buff$`stream name`,
        "<br>",
        "Priority:",
        barrier.buff$`priority`
      )
    ) %>%
    addLegend(
      data = barriers(),
      position = "bottomright",
      pal = col.structure ,
      values = barriers()$structure,
      title = "Barrier type",
      na.label = ""
    ) %>%
    addMeasure(
      position = "bottomleft",
      primaryLengthUnit = "kilometers",
      primaryAreaUnit = "ha",
      activeColor = "lightyellow",
      completedColor = "orange"
    )
  
})

leafletOutput('my.buffer', height =900)

```

Static map
=====================================

Column {.sidebar data-width=350}
-------------------------------------

The path between your selected points and the fish barriers which fall within the buffer will appear on your right.

The map is downloadable below:

<br/>

```{r}
uiOutput("download_graph_UI")

output$download_graph_UI <- renderUI({
  downloadButton("down_graph_Btn", "Download graph", style = "width:100%;")
})

output$down_graph_Btn <- downloadHandler(
  filename = "Name this reach map.png",
    content = function(file) {
      png(file=file, width = 900, height = 600)
      plot(my.map())
      dev.off()
  }
)
```


Column 
-------------------------------------

```{r}


middle <- reactive({
  # nearest edge on network
  nearest_edge_origin <-
    st_nearest_feature(origin.points(), edges2())
  nearest_edge_destination <-
    st_nearest_feature(destination.points(), edges2())
  
  # find nodes corresponding to edges
  my.origin <-
    nodes.index() %>% filter(edgeID == nearest_edge_origin)
  origin.node <- my.origin$nodeID[1:2]
  origin.node
  
  my.destination <-
    nodes.index() %>% filter(edgeID == nearest_edge_destination)
  destination.node <- my.destination$nodeID[1:2]
  destination.node
  
  # find shortest path
  node_o <- all_nodes()[origin.node,]
  node_d <- all_nodes()[destination.node,]
  
  # calculate paths (there are 4 variants)
  path1 <- shortest_paths(
    graph = graph(),
    from = origin.node[1] ,
    # new origin
    to = destination.node[1],
    # new destination
    output = 'both',
    weights = graph() %>% activate(edges) %>% pull(length)
  )
  
  path_graph1 <- graph() %>%
    subgraph.edges(eids = path1$epath %>% unlist()) %>%
    as_tbl_graph()
  
  path2 <- shortest_paths(
    graph = graph(),
    from = origin.node[2] ,
    # new origin
    to = destination.node[2],
    # new destination
    output = 'both',
    weights = graph() %>% activate(edges) %>% pull(length)
  )
  
  path_graph2 <- graph() %>%
    subgraph.edges(eids = path2$epath %>% unlist()) %>%
    as_tbl_graph()
  
  path3 <- shortest_paths(
    graph = graph(),
    from = origin.node[1] ,
    # new origin
    to = destination.node[2],
    # new destination
    output = 'both',
    weights = graph() %>% activate(edges) %>% pull(length)
  )
  
  path_graph3 <- graph() %>%
    subgraph.edges(eids = path3$epath %>% unlist()) %>%
    as_tbl_graph()
  
  path4 <- shortest_paths(
    graph = graph(),
    from = origin.node[2] ,
    # new origin
    to = destination.node[1],
    # new destination
    output = 'both',
    weights = graph() %>% activate(edges) %>% pull(length)
  )
  
  path_graph4 <- graph() %>%
    subgraph.edges(eids = path4$epath %>% unlist()) %>%
    as_tbl_graph()
  
  ### making the multilines singular
  my.path1 <-
    path_graph1 %>% activate(edges) %>% as_tibble() %>% st_as_sf()
  my.path2 <-
    path_graph2 %>% activate(edges) %>% as_tibble() %>% st_as_sf()
  my.path3 <-
    path_graph3 %>% activate(edges) %>% as_tibble() %>% st_as_sf()
  my.path4 <-
    path_graph4 %>% activate(edges) %>% as_tibble() %>% st_as_sf()
  

    my.path <- rbind(my.path1, my.path2, my.path3, my.path4)
    
    my.path 
    
    # note the bit before is different in 4.2.1
    my.path <- my.path  %>%
      summarize(geometry = st_union(st_geometry(my.path))) %>%
      st_line_merge()
    
    merged.line <- my.path  %>%
      summarize(geometry = st_combine(st_geometry(my.path))) %>%
      st_line_merge()
    
    
    ### the blade
    # cutting the line
    # make the blade for cutting
    blade <- rbind(origin.points(),
                   destination.points())  %>% st_as_sf()
    
    
    # snapping
    # turn reach into 10 m lengths
    ten.m.lengths <- round(as.numeric(st_length(merged.line)) / 10  , 0)
    merged.line.points <-
      st_sample(merged.line, size = ten.m.lengths, type = "regular") %>% st_as_sf()
    
    # find the nearest nodes which relate to the blade (observations)
    nrst <- st_nearest_points(blade, merged.line.points) %>%
      st_cast("POINT") %>% st_as_sf()
    
    # keep only the end nodes
    p_snapped <- nrst[seq(from = 2,
                          to = nrow(nrst),
                          by = 2), ]
    
    # merge the lines to produce an emulation of the reach
    merged.lines <- merged.line.points %>% st_cast("LINESTRING")
    
    # split the emulation by the blade
    parts <-
      st_collection_extract(st_split(merged.lines$x, p_snapped$x), "LINESTRING") %>%
      st_as_sf()
    
    # find the middle point of a line
    # if there are 3 lines it  will touch both other lines
    # if there are two lines it will intersect with the blade
    middle <- if (nrow(parts) == 3) {
      parts[lengths(st_touches(parts)) > 1, ]
    } else if (nrow(parts) == 2) {
      # parts %>% st_filter(st_buffer(blade, 10), .predicates = st_intersects) # buffering because can miss
      # this is where there is an ongoing issue
      touchy <- st_intersects(parts, st_buffer(blade, 200))
      parts[lengths(touchy) >= 2, ]
    } else  {
      parts
    }
    
    
    middle
  
})

```



```{r}


my.map <- reactive({
  buffered <- st_transform(middle(), crs = 2193)
  buffered <- st_buffer(buffered, input$my.buffer) %>%
    st_transform(crs = 4326)
  
  barrier.buff <- st_intersection(barriers() %>%
                                    st_transform(crs = 4326),
                                  buffered)
  
  ggplot() +
    theme_void() +
    geom_sf(
      data = graph() %>% activate(edges) %>% as_tibble() %>% st_as_sf(),
      colour = "darkgrey"
    ) +
    # geom_sf(data = origin.points(), colour = "black",  size = 7, shape = 15) +
    #  geom_sf(data = destination.points(), colour = "black", size = 7, shape = 15)+
    geom_sf(data = middle(),
            colour = "firebrick",
            lwd = 1) +
    ggtitle(paste0(
      "Catchment = ", input$my.catchments,
      "\nReach length = ",
      comma(st_length(middle()) %>%
              round(0) %>%
              as.numeric()),
      " m"
    )) +
    theme(plot.title = element_text(size = 22)) +
    theme(legend.title = element_text(size = 22)) +
    theme(legend.text = element_text(size = 18)) +
    labs(fill = paste("Structure type @", input$my.buffer, "m buffer")) +
    geom_sf(
      data = barrier.buff,
      aes(fill = structure),
      shape = 21,
      size = 5
    ) +
    annotation_scale(location = "br", text_cex = 1.2)
  
})
  
renderPlot({
    my.map()
  } , height = 900)
```

Video help
=====================================

Column {.sidebar data-width=350}
-------------------------------------

To the right is a helper video describing how to use the dashboard.


Column 
-------------------------------------


### Introduction

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/b31261e50a3041188294ff5d9dfbfa5e?sid=9bf46659-4deb-4fac-95ec-bd7832b27bce" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 75%; height: 75%;"></iframe></div>



Data check
=====================================

Row {.tabset .tabset-fade}
-------------------------------------

### Step 1: make edges
```{r}
renderPrint({edges()})
```

### Step 2: make nodes from edges
```{r}
renderPrint({nodes()})
```

### Step 3: Give each node a unique index
```{r}
renderPrint({ nodes.index()})
```

### Step 4: Combine the node indices with the edges
```{r}
renderPrint({edges2()})
```

### Step 5: Remove duplicate nodes
```{r}
renderPrint({nodes2()})
```

### Step 6: Get all nodes in the network
```{r}
renderPrint({graph()})
```

### Step 7: Get all nodes in the network
```{r}
renderPrint({all_nodes()})
```

### Step 8: Get coordinates of all nodes in the network
```{r}
renderPrint({all_coords()})
```


### Step 8: Get coordinates of all nodes in the network

```{r}
renderPrint({
  
   buffered <- st_transform(middle(), crs = 2193)
  buffered <- st_buffer(buffered, input$my.buffer) %>%
    st_transform(crs = 4326)
  
  barrier.buff <- st_intersection(barriers() %>%
                                    st_transform(crs = 4326),
                                  buffered)
  

      col.structure <- colorFactor(palette = c("red", "green", "blue", 
                                         "skyblue", "white", "yellow",
                                         "grey", "pink", "orange",
                                         "purple", "chartreuse"),
            levels = unique(barriers()$structure))
  
  })
```
