---
title: "ORC fish dashboard"
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "reproducible.co.nz", href: "https://reproducible.co.nz", align: right }
    orientation: rows
    vertical_layout: fill
    theme: spacelab
    source_code: embed 
---
<style>

body {
  padding-top: 70px;
}


.navbar-brand {
font-family: "Candara";
  font-weight: bold;
  font-size: 24px;
}


</style>


```{r}
library(sf)
library(tidyverse)
library(lubridate)
library(leaflet)
library(shiny)
library(shinyWidgets)
library(flexdashboard)
library(plotly)
library(viridis)
library(DT)
library(readxl)
library(factoextra)
library(leaflet.extras)
library(geojsonsf)
library(jsonify)
library(stringr)
library(janitor)
library(lwgeom) # for st_split
library(tidygraph)
library(sfnetworks)
library(igraph)
library(scales)
```




Sample locations
=====================================

Column {.sidebar}
-------------------------------------

**Upload species locations**

```{r}
# Upload

fileInput("file1", "Choose CSV File",
                    multiple = FALSE)


my.fish <- eventReactive(input$file1,{
  
  fish <- read.csv(input$file1$datapath) %>%
    st_as_sf(coords = c("Long", "Lat"),
               crs = 4326) %>% 
    st_transform(crs = 2193)
  
  fish$ref <- 1:nrow(fish)
  fish


})
```

<br/>

**Filter**

Please narrow your search to only the catchments required (this minimises unnecessary computation).

```{r}


renderUI({  
selectInput("my.catchments", label = "Catchments", 
    choices = sort(unique(catchments.filtered()$Catchment)),
    multiple = TRUE
)
})
  
```


<br/>

```{r}
renderUI({
  
  selectInput("start", label = "Start", 
    choices = sort(unique(my.fish()$ref)),
    selected = character(0)
  )
  
})

renderUI({
  
  selectInput("end", label = "End", 
    choices = sort(unique(my.fish()$ref)),
    selected = character(0)
  )

  
})

```

<br/>


```{r}
# Create a button for the user to submit the input
actionButton("submit", "Confirm start & end points")

my.path <- eventReactive(input$submit,{
  
  my.path <- my.fish() %>% filter(ref %in% c(input$start, input$end))
  my.path
  
})
```

```{r}
# read spatial data

# regional boundaries
boundaries <- st_read("Regional boundaries\\regional-council-2022-generalised.shp", quiet = TRUE) %>%
  st_transform(2193)

# otago boundaries
otago <- boundaries %>% filter(boundaries$REGC2022_1 == "Otago Region") %>%
  st_transform(2193)

# catchments
catchments <- st_read("ORC_Catchments\\ORC_Catchments.shp", quiet = TRUE) 

# reads in REC files (gbd format)
rec <- st_read("C:\\Users\\Nathan\\Downloads\\REC2_geodata_version_5\\nzRec2_v5.gdb", quiet = TRUE)%>%
  st_transform(2193)

# reads in non-migratory data
non.mig <-  st_read(
  "Your Non-Migratory Freshwater Fish Distribution/Non_migratory_Freshwater_Fish_Distribution.shp",
  quiet = TRUE
) %>%
  st_transform(2193)

```

```{r}
# filter non-migratory data
my.species <- "Galaxias depressiceps"
known <- non.mig %>% filter(Species == my.species)
```

```{r}
# buffer in meters
my.buffer <- 20
known.buffered <- st_buffer(known, my.buffer )%>%
  st_transform(2193)
```

```{r}
# compile max reasonable extent
box.known <-  
  st_as_sfc(st_bbox(known)) %>% 
  st_as_sf() %>%
  st_buffer(10000)

box.my <- reactive({
  
  st_as_sfc(st_bbox(my.fish())) %>% 
  st_as_sf() %>% 
  st_buffer(10000)
  
}) 
  

# join and find extent for cropping

rec.species <- reactive({
  
  combined <- rbind(box.known, box.my())
  combined <- st_as_sfc(st_bbox(combined)) %>% 
  st_as_sf()  
  
  rec.species <- st_crop(rec, combined) 
  rec.species
  
})




```


```{r}
# otago catchments

catchments.filtered  <- reactive({
  
  catchments$show <- 
  ifelse(lengths(st_intersects(catchments, known.buffered)) > 0 |
                   lengths(st_intersects(catchments, my.fish())) >0,
                           "yes",
                           "no")

catchments.filtered <- catchments %>% filter(show == "yes")
catchments.filtered 

})



```

```{r}
# reduce 
masked.rec.species <- reactive({
  
  st_intersection(rec.species(), final.catchments())
  
})
```



Column
-------------------------------------


```{r}

output$mymap  <- renderLeaflet({
  
leaflet(options = leafletOptions(worldCopyJump = TRUE)) %>%
  
  # add base maps
  addProviderTiles("Esri.WorldImagery",
                   # give the layer a name
                   group = "World") %>%
  # set zoom and position
  setView(lng = 169,
          lat = -45.9,
          zoom = 8) %>%
  addPolygons(data = catchments.filtered() %>% st_transform(crs =4326),
              fillOpacity = 0.1,
              color = "red",
              weight = 3,
              popup = paste(catchments.filtered()$Catchment))%>%
  addMarkers(data = my.fish() %>% 
               st_transform(crs =4326),
             popup = paste(my.fish()$ref)) %>%
  addPolylines(data = masked.rec.species() %>% st_transform(crs =4326),
              fillOpacity = 0.001,
              color = "white",
              weight = 3)
  
})

leafletOutput('mymap', height=1000)

```

Pathways
=====================================


Column {.sidebar}
-------------------------------------

```{r}
# filter by my catchments

final.catchments <- reactive({
  
  final.catchments <- catchments.filtered() %>% 
    filter(Catchment %in% input$my.catchments)
  final.catchments 
  
  
})

```


Column
-------------------------------------

```{r}

output$mycatch  <- renderLeaflet({
  
leaflet(options = leafletOptions(worldCopyJump = TRUE)) %>%
  
  # add base maps
  addProviderTiles("Esri.WorldImagery",
                   # give the layer a name
                   group = "World") %>%
  # set zoom and position
  setView(lng = 169,
          lat = -45.9,
          zoom = 8) %>%
  addMarkers(data = my.path() %>% 
               st_transform(crs = 4326)) %>%
  addPolygons(data = final.catchments() %>% 
                st_transform(crs = 4326),
              fillOpacity = 0.001,
              color = "red",
              weight = 3) %>%
    addPolylines(data = masked.rec.species() %>% 
                   st_transform(crs = 4326),
              fillOpacity = 0.001,
              color = "white",
              weight = 3)
  
})

leafletOutput('mycatch', height=1000)
```



```{r}
########## Network analysis
# Step 1: make edges
edges <- reactive ({
  masked.rec.species() %>%
    mutate(edgeID = c(1:n()))
  
})


# Step 2: make nodes from edges
nodes <- reactive ({
  edges() %>%
    st_coordinates() %>%
    as_tibble() %>%
    rename(edgeID = L1) %>%
    group_by(edgeID) %>%
    slice(c(1, n())) %>%
    ungroup() %>%
    mutate(start_end = rep(c('start', 'end'), times = n() / 2))
  
})

# Step 3: Give each node a unique index

# make moniker
nodes.index  <- reactive ({
  nodes.index  <- nodes()
  
  nodes.index$xy <-  paste(nodes.index$X, nodes.index$Y)
  nodes.index$xy <-
    factor(nodes.index$xy, levels = unique(nodes.index$xy))
  nodes.index$nodeID <- as.numeric(nodes.index$xy)
  nodes.index$xy <- NULL
  
  nodes.index
  
})

# Step 4: Combine the node indices with the edges

edges2 <- reactive({
  
  source_nodes <- nodes.index() %>%
    filter(start_end == 'start') %>%
    pull(nodeID)
  
  target_nodes <- nodes.index() %>%
    filter(start_end == 'end') %>%
    pull(nodeID)
  
  edges2 <-  edges() %>%
    mutate(from = source_nodes, to = target_nodes)
  
  edges2
  
})


# Step 5: Convert to tbl_graph
graph <-  reactive({
  
  graph <- tbl_graph(nodes = nodes(), 
                     edges = as_tibble(edges2()), 
                    directed = FALSE) %>% 
    activate(edges2()) %>% 
    mutate(length = st_length(st_geometry(edges2)))


# this might be a version 4.2.1 solution only
 # graph <- graph %>% activate(edges2()) %>% mutate(length = st_length(st_geometry(edges2)))
  
  graph
  
})

# Step 6: Get all nodes in the network
all_nodes <- reactive({
  
  graph() %>%
  activate(nodes()) %>%
  as_tibble() %>%
  st_as_sf()
  
})


# Step 7: Get coordinates of all nodes in the network

all_coords <- reactive({
  
  all_nodes() %>%
  st_coordinates()
  
})


```

Data
=====================================

Row {.tabset .tabset-fade}
-------------------------------------

### Step 1: make edges
```{r}
renderPrint({edges()})
```

### Step 2: make nodes from edges
```{r}
renderPrint({nodes()})
```

### Step 3: Give each node a unique index
```{r}
renderPrint({ nodes.index()})
```

### Step 4: Combine the node indices with the edges
```{r}
renderPrint({edges2()})
```

### Step 5: Get all nodes in the network
```{r}
renderPrint({graph()})
```

### Step 6: Get all nodes in the network
```{r}
renderPrint({all_nodes()})
```

### Step 7: Get coordinates of all nodes in the network
```{r}
renderPrint({all_coords()})
```
